<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><title>Blog 0.1.0</title><meta content="Just an experiment" name="description"><meta content="Spencer" name="author"><meta content="width=device-width, initial-scale=1" name="viewport"><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" rel="stylesheet"><link href="/css/my-css.css" rel="stylesheet" type="text/css"><link href="/resources/favicons/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180"><link href="/resources/favicons/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"><link href="/resources/favicons/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"><link href="/resources/favicons/site.webmanifest.json" rel="manifest"><link href="/resources/favicons/favicon.ico" rel="icon"></head><body><div class="container"><div class="row"><h1><a href="/">Here we go...</a></h1></div><div class="row"><div class="col-md-9"><div class="main-post-area"><div class="row"><h3>Notes from a Discussion on Handling Emergency Service Outages</h3><h5>2021-02-04</h5><div class="post-body"><p>I had a great conversation with a wise colleague from work in the aftermath of a small emergency software outage. </p><h4>How to handle an emergency outage</h4><ul><li class="list-level-0">Don’t freak out when something bad happens</li><li class="list-level-1">Being freaked out makes it harder to think</li><li class="list-level-1">Taking action based on immediate reactions can cause poor decisions that cause more issues</li><li class="list-level-0">Don’t just rollback immediately</li><li class="list-level-1">You will have lost your best resource for debugging - the system that was actually failing</li><li class="list-level-1">You can’t deploy again because things will break again</li><li class="list-level-1">But you can’t fix the problem because you don’t know exactly what failed!</li><li class="list-level-2">You will have to just guess at what caused the problem</li><li class="list-level-0">Reproduce the error yourself to see what exactly is failing</li><li class="list-level-1">Logs are just hearsay</li><li class="list-level-2">You can’t double-check them</li><li class="list-level-2">Circumstantial evidence</li><li class="list-level-3">They usually collect behavior, give trends, but you don’t see exactly how each function responds in each situation and youcan’t dig down usually</li><li class="list-level-1">Circumstantial evidence is not good evidence, don’t let it lead you down a false path</li><li class="list-level-0">Once you can reproduce and know what the problem is, then you can rollback</li><li class="list-level-0">Need an ability to quickly query the service to reproduce the error</li><li class="list-level-1">Need it to be fast, easy to use, easy to modify</li><li class="list-level-1">Postman can be good for this</li><li class="list-level-2">Shared team workspace for saving queries we all use</li><li class="list-level-2">Easily change details to look at more things</li><li class="list-level-2">Easy to see what is happening, in case debugging is needed</li><li class="list-level-1">Scripted curls can be really nice, but can also break and be unfixable</li><li class="list-level-1">Writing scripts in clojure could be nice, but could have same problems as scripts</li></ul><h4>Design for failures</h4><ul><li class="list-level-0">Networked systems fail often, thus:</li><li class="list-level-0">Designing for the failing case is as important, if not more, than designing for the success case</li><li class="list-level-0">Designing for failing case involves avoiding these problems</li><li class="list-level-1">Looking like it failed but it actually succeeded (e.g. timeout/dropped connection, but kept working and succeeded on other side)</li><li class="list-level-1">Looking like it succeeded but it actually failed (rarer, but e.g. nothing is returned at all and that’s assumed to be good)</li><li class="list-level-1">Not knowing at all if something passed or failed (no return value), so you need to check it with a separate call</li><li class="list-level-0">Want things to fail loudly and fast</li><li class="list-level-0">Resiliency - if it failed it should be able to try again safely, and do that</li></ul></div></div><div class="row"><h3>Roller Coast Tycoon</h3><h5>2021-02-02</h5><div class="post-body"><p>Roller Coaster Tycoon is a classic theme park simulator computer game. I played the second edition that came out in 2002. I recently rediscovered the game and am amazed by how fun it still is to put together roller coasters, set prices for hamburger stands, strategically place benches and trash cans on paths near nauseating rides, run marketing campaigns, and listen in on the thoughts of the park visitors. The isometric view and low-res graphics are very attractive and the sound effects really make it feel fun and alive.</p><p>Unfortunately it only runs on Windows machines, and I have a Mac. A few years ago I was able to figure out how to get it working with [Wine](https://www.winehq.org/), a compatability layer that translates Windows operating system API calls into code that Unix-based operating systems, like macOS, can understand. But Wine can't yet handle 64-bit apps, so it's been broken on macOS Catalina, which doesn't let you run 32-bit apps.Luckily I was able to find [PlayOnMac](https://www.playonmac.com/en/), which apparently has been adapted to be able to handle 64-bit apps, so I was able to install that, install Windows Steam via that, and then download and run Roller Coast Tycoon 2 from Steam. Great! </p></div></div><div class="row"><h3>Starting with GitHub Actions</h3><h5>2021-02-01</h5><div class="post-body"><p>So I had GitHub hosting my site, and I had code that generated my site from Markdown files, which was great and free. But GitHub is just a static code repository, so I had to write a post and run the code that generates thewebsite locally before pushing it up to GitHub. GitHub can't run the code that generates the website server-side every time I push an update... or can it?</p><p>Enter GitHub Actions! I remembered that this exists and that it can do some sort of server-side code execution because my company uses it to run tests. So I got the default Clojure GitHub Actions template and created a test that would run the code that generates the website. Normally it would just throw away any changes that were made as a result of running tests, but I discovered that there's a GitHub Actions Marketplace full of cool Actions functions, including one by steganzweifel (https://github.com/marketplace/actions/git-auto-commit) that automatically commits code changes that happen during an Action.    </p><p>Putting all those things together, I now have a workflow where I can write a post in Markdown and push it to GitHub and it'll be live on the site within a minute or two. Very exciting. </p><h4>Todo list</h4><ul><li class="list-level-0">Turn tags into a set</li><li class="list-level-0">Put tags in ToC</li><li class="list-level-0">Put vertical spacing in main post area of home page</li><li class="list-level-0">Improve Markdown parser/Hiccup converter</li><li class="list-level-1">Understand indented sub-bullets</li><li class="list-level-1">Make links work correctly</li><li class="list-level-1">Use mono font for `code` and ```code blocks```</li><li class="list-level-0">Dark mode (button or permanent?)</li></ul></div></div><div class="row"><h3>Markdown Parser Converter Round 1</h3><h5>2021-01-26</h5><div class="post-body"><p>This post will be short, but not because of a lack of updates to the technical workings of the blog! I perhaps should've made smaller, more frequent posts, but I got very excited and motivated working on the things I'm about to describe.</p><p>First of all, I'm now writing this in a Markdown file which my IDE renders in live time, which is a much nicer experience that writing prose into a vector in the body of Clojure code. When the `generate-index-html!` function is called, it iterates through all the markdown blog post files in this folder, does some woefully incomplete parsing of the Markdown and converts each post into a Clojure hashmap with some metadata. The function then turns that vector of blog post hashmaps into Hiccup code and puts the posts in the main section of the webpage.</p><p>I decided to read all the Markdown posts into a vector of blog post hashmaps so that I could use it for multiple things on the website. For one, it is used to populate the Table of Contents. It is also used to create unique pages for each post, which I'll soon be linking to in the Table of Contents.</p><p>I think I'll split the Github Actions deployment description into a separate post for now.</p></div></div><div class="row"><h3>My Plan For This Blog Right Now</h3><h5>2021-01-24</h5><div class="post-body"><p>Maybe I'll make this into a design diary (à la Stonemaier Games design diaries) for now.</p><p>Right now I'm just typing strings into vectors that [Hiccup](https://github.com/weavejester/hiccup), a Clojure library, will turn into HTML code, which I'll push to Github. I hope to be able to write notes in Markdown that my program will convert into Clojure data structures with lots of metadata that will be put into Hiccup to make HTML. That's the dream. Probably not too hard if I'm able to devote some time to figuring it out.</p><p>I also want to make the layout and styling look decent. I am starting using Bootstrap, but it's very rudimentary right now (something that future people reading this hopefully won't be able to see). I have a lot of learning and experimenting to do. Including figuring out how to balance time between writing the blog and making the blog.</p><p>Teaser for next time: I remembered Github actions and discovered Git Auto Commit! https://github.com/marketplace/actions/git-auto-commit</p></div></div><div class="row"><h3>Post #1</h3><h5>2021-01-22</h5><div class="post-body"><p>I pledge that these blog posts will either:</p><ul><li class="list-level-0">be short, or</li><li class="list-level-0">have lots of pictures/diagrams</li></ul></div></div></div></div><div class="col-sm order-first order-md-last"><div class="toc"><h4>Table of Contents</h4><div class="toc"><div class="post-titles"><ul><li><a href="/posts/2021-02-04/notes-from-a-discussion-on-handling-emergency-service-outages.html">Notes from a Discussion on Handling Emergency Service Outages</a></li><li><a href="/posts/2021-02-02/roller-coast-tycoon.html">Roller Coast Tycoon</a></li><li><a href="/posts/2021-02-01/starting-with-github-actions.html">Starting with GitHub Actions</a></li><li><a href="/posts/2021-01-26/markdown-parser-converter-round-1.html">Markdown Parser Converter Round 1</a></li><li><a href="/posts/2021-01-24/my-plan-for-this-blog-right-now.html">My Plan For This Blog Right Now</a></li><li><a href="/posts/2021-01-22/post-1.html">Post #1</a></li></ul></div><div class="post-tags"><h5>Tags</h5><ul><li>computergames</li><li>technical</li><li>meta</li><li>software-design</li></ul></div></div></div></div></div><br><br><br><div class="row"><div class="footer"><p>The code to generate this website is at <a href="https://github.com/spencerminer/blog/">github.com/spencerminer/blog/</a></p></div></div></div><script crossorigin="anonymous" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js"></script></body></html>